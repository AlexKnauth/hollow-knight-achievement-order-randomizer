#lang rhombus/static/and_meta

export:
  hollow_knight_achievement_order_randomizer
  is_achievement_order_in_logic
  print_achievement_order

import:
  rhombus/runtime_path
  rhombus/shrubbery
  lib("racket/base.rkt").#{open-input-file} as open_input_file
  "entry.rhm" open

runtime_path.def AARAO_txt: "AARAO.txt"
runtime_path.def Charms_txt: "Charms.txt"
runtime_path.def Completion_txt: "Completion.txt"
runtime_path.def Essence_txt: "Essence.txt"

def AARAO_in: open_input_file(AARAO_txt)
def Charms_in: open_input_file(Charms_txt)
def Completion_in: open_input_file(Completion_txt)
def Essence_in: open_input_file(Essence_txt)

def AARAO_shrb: shrubbery.read(AARAO_in)
def Charms_shrb: shrubbery.read(Charms_in)
def Completion_shrb: shrubbery.read(Completion_in)
def Essence_shrb: shrubbery.read(Essence_in)

def init:
  {
    #'SHADESKIP: #true,
    #'RANDOM_ESSENCE_DROPS: #false,
    #'TREES_AND_GHOSTS: #true,
  }

syntax_class RequirementsTerm:
  fields: function
  kind: ~term
| '#true': field function: fun(_): #true
| '#false': field function: fun(_): #false
| '$(name :: Name)':
    field function: fun(map): Map.get(map, name.symbol, #false)
| '($(requirements :: Group))':
    field function: requirements_group_function(requirements)

syntax_class RequirementsGroup:
  fields: function
  kind: ~group
| '$(a :: RequirementsTerm) $('+ $(b :: RequirementsTerm)') ...':
    field function: fun(map): all(a.function(map), b.function(map), ...)
| '$(a :: RequirementsTerm) $('|| $(b :: RequirementsTerm)') ...':
    field function: fun(map): any(a.function(map), b.function(map), ...)

fun requirements_group_function('$(requirements :: RequirementsGroup)'):
  requirements.function

syntax_class RequirementEntry:
  kind: ~group
  fields: symbol; function
| '$(entry :: Entry)':
    field symbol: entry.symbol
    field function: requirements_group_function(entry.requirements)

syntax_class NumberEntry:
  kind: ~group
  fields: symbol; function
| '$(entry :: Entry)':
    field symbol: entry.symbol
    def requirement_function: requirements_group_function(entry.requirements)
    field function: fun(map): (requirement_function(map) && entry.number) || 0

syntax_class RequirementEntries:
  kind: ~multi
  fields: map
| '$(entry :: RequirementEntry); ...':
    field map: { entry.symbol: entry.function, ... }

syntax_class NumberEntries:
  kind: ~multi
  fields: map
| '$(entry :: NumberEntry); ...':
    field map: { entry.symbol: entry.function, ... }

def '$(AARAO_entries :: RequirementEntries)': AARAO_shrb
def '$(Charms_entries :: NumberEntries)': Charms_shrb
def '$(Completion_entries :: NumberEntries)': Completion_shrb
def '$(Essence_entries :: NumberEntries)': Essence_shrb

def AARAO_map :: Map: AARAO_entries.map
def Charms_map :: Map: Charms_entries.map
def Completion_map :: Map: Completion_entries.map
def Essence_map :: Map: Essence_entries.map

def AARAO_keys: AARAO_map.keys()

fun next(progression :: Map, remaining :: List):
  match remaining
  | []: #false
  | _:
      let possible:
        for List (x: remaining):
          keep_when: AARAO_map[x](progression)
          x
      possible[math.random(possible.length())]

fun loop(progression :: Map, remaining :: List, given :: List):
  let n: next(progression, remaining)
  cond
  | n: loop(progression ++ {n: #true}, remaining.remove(n), given.add(n))
  | ~else: given

fun hollow_knight_achievement_order_randomizer() :: List.of(Symbol):
  loop(init, AARAO_keys, [])

fun is_achievement_order_in_logic(order :: List.of(Symbol)) :: Boolean:
  for all (i: 0..order.length()):
    let [prev, ...]: order.take(i)
    let progression: init ++ { prev: #true, ... }
    AARAO_map[order[i]](progression)

fun print_achievement_order(order :: List.of(Symbol)):
  for (a: order):
    println(a)

module main:
  print_achievement_order(hollow_knight_achievement_order_randomizer())

module test:
  fun index_of(lst :: List, v) :: maybe(Int):
    for values(_: #false) (e: lst, i: 0..):
      keep_when: e == v
      final_when: #true
      i
  check: index_of([#'a, #'b, #'c], #'b) ~is 1
  check: index_of([#'a, #'b, #'c], #'d) ~is #false

  check:
    is_achievement_order_in_logic([#'TestOfResolve, #'ProofOfResolve, #'Execution])
    ~is #true
  check:
    is_achievement_order_in_logic([#'ProofOfResolve, #'TestOfResolve, #'Execution])
    ~is #true
  check:
    is_achievement_order_in_logic([#'ProofOfResolve, #'Execution, #'TestOfResolve])
    ~is #false

  for (_: 0..100):
    use_dynamic
    let order: hollow_knight_achievement_order_randomizer()
    check: order.length() ~is 63
    let hornet1: index_of(order, #'TestOfResolve)
    let hornet2: index_of(order, #'ProofOfResolve)
    let traitor_lord: index_of(order, #'Execution)
    let radiance: index_of(order, #'DreamNoMore)
    check: hornet1 < traitor_lord ~is #true
    check: hornet2 < traitor_lord ~is #true
    check: traitor_lord < radiance ~is #true

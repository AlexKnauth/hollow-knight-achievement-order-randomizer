#lang rhombus/static/and_meta

export:
  hollow_knight_achievement_order_randomizer
  is_achievement_order_in_logic
  print_achievement_order

import:
  rhombus/runtime_path
  rhombus/shrubbery
  lib("racket/base.rkt").#{open-input-file} as open_input_file

runtime_path.def AARAO_txt: "AARAO.txt"

def AARAO_in: open_input_file(AARAO_txt)

def AARAO_shrb: shrubbery.read(AARAO_in)

def init:
  {
    #'SHADESKIP: #true,
  }

syntax_class Num:
  kind: ~term
| '$n':
    match_when: Syntax.unwrap(n) is_a Number

syntax_class Name:
  kind: ~term
  fields: symbol
| '$(id :: Identifier)':
    field symbol: Syntax.unwrap(id)

syntax_class RequirementsTerm:
  fields: function
  kind: ~term
| '$(name :: Name)':
    field function: fun(map): Map.get(map, name.symbol, #false)
| '($(requirements :: Group))':
    field function: requirements_group_function(requirements)

syntax_class RequirementsGroup:
  fields: function
  kind: ~group
| '$(a :: RequirementsTerm) $('+ $(b :: RequirementsTerm)') ...':
    field function: fun(map): all(a.function(map), b.function(map), ...)
| '$(a :: RequirementsTerm) $('|| $(b :: RequirementsTerm)') ...':
    field function: fun(map): any(a.function(map), b.function(map), ...)

fun requirements_group_function('$(requirements :: RequirementsGroup)'):
  requirements.function

syntax_class Entry:
  kind: ~group
  fields: symbol; function
| '$(_ :: Num) $(name :: Name)':
    field symbol: name.symbol
    field function: fun(map): #true
| '$(_ :: Num) $(name :: Name): $(requirements :: RequirementsGroup)':
    field symbol: name.symbol
    field function: requirements.function

syntax_class Entries:
  kind: ~multi
  fields: map
| '$(entry :: Entry); ...':
    field map: { entry.symbol: entry.function, ... }

def '$(entries :: Entries)': AARAO_shrb

def AARAO_map :: Map: entries.map

def AARAO_keys: AARAO_map.keys()

fun next(progression :: Map, remaining :: List):
  match remaining
  | []: #false
  | _:
      let possible:
        for List (x: remaining):
          keep_when: AARAO_map[x](progression)
          x
      possible[math.random(possible.length())]

fun loop(progression :: Map, remaining :: List, given :: List):
  let n: next(progression, remaining)
  cond
  | n: loop(progression ++ {n: #true}, remaining.remove(n), given.add(n))
  | ~else: given

fun hollow_knight_achievement_order_randomizer() :: List.of(Symbol):
  loop(init, AARAO_keys, [])

fun is_achievement_order_in_logic(order :: List.of(Symbol)) :: Boolean:
  for all (i: 0..order.length()):
    let [prev, ...]: order.take(i)
    let progression: init ++ { prev: #true, ... }
    AARAO_map[order[i]](progression)

fun print_achievement_order(order :: List.of(Symbol)):
  for (a: order):
    println(a)

module main:
  print_achievement_order(hollow_knight_achievement_order_randomizer())

module test:
  fun index_of(lst :: List, v) :: maybe(Int):
    for values(_: #false) (e: lst, i: 0..):
      keep_when: e == v
      final_when: #true
      i
  check: index_of([#'a, #'b, #'c], #'b) ~is 1
  check: index_of([#'a, #'b, #'c], #'d) ~is #false

  check:
    is_achievement_order_in_logic([#'TestOfResolve, #'ProofOfResolve, #'Execution])
    ~is #true
  check:
    is_achievement_order_in_logic([#'ProofOfResolve, #'TestOfResolve, #'Execution])
    ~is #true
  check:
    is_achievement_order_in_logic([#'ProofOfResolve, #'Execution, #'TestOfResolve])
    ~is #false

  for (_: 0..100):
    use_dynamic
    let order: hollow_knight_achievement_order_randomizer()
    check: order.length() ~is 63
    let hornet1: index_of(order, #'TestOfResolve)
    let hornet2: index_of(order, #'ProofOfResolve)
    let traitor_lord: index_of(order, #'Execution)
    let radiance: index_of(order, #'DreamNoMore)
    check: hornet1 < traitor_lord ~is #true
    check: hornet2 < traitor_lord ~is #true
    check: traitor_lord < radiance ~is #true
